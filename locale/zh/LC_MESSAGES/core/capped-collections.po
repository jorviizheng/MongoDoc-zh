#
msgid ""
msgstr ""
"Project-Id-Version: mongodb-manual 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-08-20 19:13-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/core/capped-collections.txt:3
msgid "Capped Collections"
msgstr ""

#: ../source/core/capped-collections.txt:16
msgid ""
":term:`Capped collections <capped collection>` are fixed-size collections "
"that support high-throughput operations that insert and retrieve documents "
"based on insertion order. Capped collections work in a way similar to "
"circular buffers: once a collection fills its allocated space, it makes room"
" for new documents by overwriting the oldest documents in the collection."
msgstr ""

#: ../source/core/capped-collections.txt:23
msgid ""
"See :method:`~db.createCollection()` or :dbcommand:`create` for more "
"information on creating capped collections."
msgstr ""

#: ../source/core/capped-collections.txt:44
msgid ""
"For example, the :term:`oplog.rs <oplog>` collection that stores a log of "
"the operations in a :term:`replica set` uses a capped collection. Consider "
"the following potential use cases for capped collections:"
msgstr ""

#: ../source/core/capped-collections.txt:49
msgid ""
"Store log information generated by high-volume systems. Inserting documents "
"in a capped collection without an index is close to the speed of writing log"
" information directly to a file system. Furthermore, the built-in *first-in-"
"first-out* property maintains the order of events, while managing storage "
"use."
msgstr ""

#: ../source/core/capped-collections.txt:55
msgid ""
"Cache small amounts of data in a capped collections. Since caches are read "
"rather than write heavy, you would either need to ensure that this "
"collection *always* remains in the working set (i.e. in RAM) *or* accept "
"some write penalty for the required index or indexes."
msgstr ""

#: ../source/core/capped-collections.txt:95
msgid "You cannot shard a capped collection."
msgstr ""

#: ../source/core/capped-collections.txt:100
msgid ""
"Use natural ordering to retrieve the most recently inserted elements from "
"the collection efficiently. This is (somewhat) analogous to tail on a log "
"file."
msgstr ""

#: ../source/core/capped-collections.txt:107
msgid ""
"The aggregation pipeline operator :pipeline:`$out` cannot write results to a"
" capped collection."
msgstr ""

#: ../source/core/capped-collections.txt:113
msgid "Procedures"
msgstr ""

#: ../source/core/capped-collections.txt:116
msgid "Create a Capped Collection"
msgstr ""

#: ../source/core/capped-collections.txt:130
msgid ""
"If the ``size`` field is less than or equal to 4096, then the collection "
"will have a cap of 4096 bytes. Otherwise, MongoDB will raise the provided "
"size to make it an integer multiple of 256."
msgstr ""

#: ../source/core/capped-collections.txt:134
msgid ""
"Additionally, you may also specify a maximum number of documents for the "
"collection using the ``max`` field as in the following document:"
msgstr ""

#: ../source/core/capped-collections.txt:141
msgid ""
"The ``size`` argument is *always* required, even when you specify ``max`` "
"number of documents. MongoDB will remove older documents if a collection "
"reaches the maximum size limit before it reaches the maximum document count."
msgstr ""

#: ../source/core/capped-collections.txt:0
msgid "See"
msgstr ""

#: ../source/core/capped-collections.txt:151
msgid "Query a Capped Collection"
msgstr ""

#: ../source/core/capped-collections.txt:153
msgid ""
"If you perform a :method:`~db.collection.find()` on a capped collection with"
" no ordering specified, MongoDB guarantees that the ordering of results is "
"the same as the insertion order."
msgstr ""

#: ../source/core/capped-collections.txt:157
msgid ""
"To retrieve documents in reverse insertion order, issue "
":method:`~db.collection.find()` along with the :method:`~cursor.sort()` "
"method with the :operator:`$natural` parameter set to ``-1``, as shown in "
"the following example:"
msgstr ""

#: ../source/core/capped-collections.txt:167
msgid "Check if a Collection is Capped"
msgstr ""

#: ../source/core/capped-collections.txt:169
msgid ""
"Use the :method:`~db.collection.isCapped()` method to determine if a "
"collection is capped, as follows:"
msgstr ""

#: ../source/core/capped-collections.txt:177
msgid "Convert a Collection to Capped"
msgstr ""

#: ../source/core/capped-collections.txt:179
msgid ""
"You can convert a non-capped collection to a capped collection with the "
":dbcommand:`convertToCapped` command:"
msgstr ""

#: ../source/core/capped-collections.txt:186
msgid ""
"The ``size`` parameter specifies the size of the capped collection in bytes."
msgstr ""

#: ../source/includes/warning-blocking-global.rst:3
msgid ""
"This command obtains a global write lock and will block other operations "
"until it has completed."
msgstr ""

#: ../source/core/capped-collections.txt:192
msgid "Automatically Remove Data After a Specified Period of Time"
msgstr ""

#: ../source/core/capped-collections.txt:194
msgid ""
"For additional flexibility when expiring data, consider MongoDB's "
":term:`TTL` indexes, as described in :doc:`/tutorial/expire-data`. These "
"indexes allow you to expire and remove data from normal collections using a "
"special type, based on the value of a date-typed field and a TTL value for "
"the index."
msgstr ""

#: ../source/core/capped-collections.txt:200
msgid ""
":doc:`TTL Collections </tutorial/expire-data>` are not compatible with "
"capped collections."
msgstr ""

#: ../source/core/capped-collections.txt:204
msgid "Tailable Cursor"
msgstr ""

#: ../source/core/capped-collections.txt:206
msgid ""
"You can use a :term:`tailable cursor` with capped collections. Similar to "
"the Unix ``tail -f`` command, the tailable cursor \"tails\" the end of a "
"capped collection. As new documents are inserted into the capped collection,"
" you can use the tailable cursor to continue retrieving documents."
msgstr ""

#: ../source/core/capped-collections.txt:0
msgid "On this page"
msgstr ""

#: ../source/core/capped-collections.txt:14
msgid "Overview"
msgstr ""

#: ../source/core/capped-collections.txt:27
msgid "Behavior"
msgstr ""

#: ../source/core/capped-collections.txt:30
msgid "Insertion Order"
msgstr ""

#: ../source/core/capped-collections.txt:32
msgid ""
"Capped collections guarantee preservation of the insertion order. As a "
"result, queries do not need an index to return documents in insertion order."
" Without this indexing overhead, capped collections can support higher "
"insertion throughput."
msgstr ""

#: ../source/core/capped-collections.txt:38
msgid "Automatic Removal of Oldest Documents"
msgstr ""

#: ../source/core/capped-collections.txt:40
msgid ""
"To make room for new documents, capped collections automatically remove the "
"oldest documents in the collection without requiring scripts or explicit "
"remove operations."
msgstr ""

#: ../source/core/capped-collections.txt:62
msgid "``_id`` Index"
msgstr ""

#: ../source/core/capped-collections.txt:64
msgid ""
"Capped collections have an ``_id`` field and an index on the ``_id`` field "
"by default."
msgstr ""

#: ../source/core/capped-collections.txt:70
msgid "Restrictions and Recommendations"
msgstr ""

#: ../source/core/capped-collections.txt:73
msgid "Updates"
msgstr ""

#: ../source/core/capped-collections.txt:75
msgid ""
"If you plan to update documents in a capped collection, create an index so "
"that these update operations do not require a collection scan."
msgstr ""

#: ../source/core/capped-collections.txt:79
msgid "Document Size"
msgstr ""

#: ../source/includes/extracts/capped-collection-immutable-document-size.rst:1
msgid ""
"If an update or a replacement operation changes the document size, the "
"operation will fail."
msgstr ""

#: ../source/core/capped-collections.txt:86
msgid "Document Deletion"
msgstr ""

#: ../source/core/capped-collections.txt:88
msgid ""
"You cannot delete documents from a capped collection. To remove all "
"documents from a collection, use the :method:`~db.collection.drop()` method "
"to drop the collection and recreate the capped collection."
msgstr ""

#: ../source/core/capped-collections.txt:93
msgid "Sharding"
msgstr ""

#: ../source/core/capped-collections.txt:98
msgid "Query Efficiency"
msgstr ""

#: ../source/core/capped-collections.txt:105
msgid "Aggregation ``$out``"
msgstr ""

#: ../source/core/capped-collections.txt:118
msgid ""
"You must create capped collections explicitly using the "
":method:`db.createCollection()` method, which is a helper in the "
":program:`mongo` shell for the :dbcommand:`create` command. When creating a "
"capped collection you must specify the maximum size of the collection in "
"bytes, which MongoDB will pre-allocate for the collection. The size of the "
"capped collection includes a small amount of space for internal overhead."
msgstr ""

#: ../source/core/capped-collections.txt:212
msgid ""
"See :doc:`/core/tailable-cursors` for information on creating a tailable "
"cursor."
msgstr ""

#~ msgid "Capped collections have the following behaviors:"
#~ msgstr ""

#~ msgid ""
#~ "Capped collections guarantee preservation of the insertion order. As a "
#~ "result, queries do not need an index to return documents in insertion order."
#~ " Without this indexing overhead, they can support higher insertion "
#~ "throughput."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections guarantee that insertion order is identical to the order "
#~ "on disk (:term:`natural order`) and do so by prohibiting updates that "
#~ "increase document size. Capped collections only allow updates that fit the "
#~ "original document size, which ensures a document does not change its "
#~ "location on disk."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections automatically remove the oldest documents in the "
#~ "collection without requiring scripts or explicit remove operations."
#~ msgstr ""

#~ msgid "Recommendations and Restrictions"
#~ msgstr ""

#~ msgid ""
#~ "You can only make in-place updates of documents. If the update operation "
#~ "causes the document to grow beyond their original size, the update operation"
#~ " will fail."
#~ msgstr ""

#~ msgid ""
#~ "If you plan to update documents in a capped collection, create an index so "
#~ "that these update operations do not require a table scan."
#~ msgstr ""

#~ msgid ""
#~ "If you update a document in a capped collection to a size smaller than its "
#~ "original size, and then a secondary resyncs from the primary, the secondary "
#~ "will replicate and allocate space based on the current smaller document "
#~ "size. If the primary then receives an update which increases the document "
#~ "back to its original size, the primary will accept the update but the "
#~ "secondary will fail with a ``failing update: objects in a capped ns cannot "
#~ "grow`` error message."
#~ msgstr ""

#~ msgid ""
#~ "To prevent this error, create your secondary from a snapshot of one of the "
#~ "other up-to-date members of the replica set. Follow :doc:`our tutorial on "
#~ "filesystem snapshots </tutorial/backup-with-filesystem-snapshots>` to seed "
#~ "your new secondary."
#~ msgstr ""

#~ msgid ""
#~ "Seeding the secondary with a filesystem snapshot is the only way to "
#~ "guarantee the primary and secondary binary files are compatible. |MMS| "
#~ "Backup snapshots are insufficient in this situation since you need more than"
#~ " the content of the secondary to match the primary."
#~ msgstr ""

#~ msgid ""
#~ "You cannot delete documents from a capped collection.  To remove all "
#~ "documents from a collection, use the :method:`~db.collection.drop()` method "
#~ "to drop the collection."
#~ msgstr ""

#~ msgid ""
#~ "Capped collections created after 2.2 have an ``_id`` field and an index on "
#~ "the ``_id`` field by default. Capped collections created before 2.2 do not "
#~ "have an index on the ``_id`` field by default. If you are using capped "
#~ "collections with replication prior to 2.2, you should explicitly create an "
#~ "index on the ``_id`` field."
#~ msgstr ""

#~ msgid ""
#~ "If you have a capped collection in a :term:`replica set` outside of the "
#~ "``local`` database, before 2.2, you should create a unique index on ``_id``."
#~ " Ensure uniqueness using the ``unique: true`` option to the "
#~ ":method:`~db.collection.createIndex()` method or by using an "
#~ ":term:`ObjectId` for the ``_id`` field. Alternately, you can use the "
#~ "``autoIndexId`` option to :dbcommand:`create` when creating the capped "
#~ "collection, as in the :ref:`capped-collections-options` procedure."
#~ msgstr ""

#~ msgid ""
#~ "You must create capped collections explicitly using the "
#~ ":method:`~db.createCollection()` method, which is a helper in the "
#~ ":program:`mongo` shell for the :dbcommand:`create` command. When creating a "
#~ "capped collection you must specify the maximum size of the collection in "
#~ "bytes, which MongoDB will pre-allocate for the collection. The size of the "
#~ "capped collection includes a small amount of space for internal overhead."
#~ msgstr ""

#~ msgid ""
#~ "Before 2.2, capped collections did not have an index on ``_id`` unless you "
#~ "specified ``autoIndexId`` to the :dbcommand:`create`, after 2.2 this became "
#~ "the default."
#~ msgstr ""

#~ msgid ""
#~ "See :doc:`/tutorial/create-tailable-cursor` for information on creating a "
#~ "tailable cursor."
#~ msgstr ""
